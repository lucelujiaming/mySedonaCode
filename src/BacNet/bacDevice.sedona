@niagaraIcon="module://icons/x16/device.png"
class bacDevice
  extends FieldBusDevice
{
  @config
  property int deviceInstance = 0

  // Lujiaming add these at 23/05/22
  define Str BVLCISTATUSRANGE = "NoBVLCI, DistributeBroadcastToNetWork, Unicast, Broadcast, ForwardNPDU_WT, END"
  define int BVLCISTATUSNOBVLCI = 0
  define int BVLCISTATUSDISTRIBUTEBROADCAST = 1
  define int BVLCISTATUSUNICAST = 2
  define int BVLCISTATUSBROADCAST = 3
  define int BVLCISTATUSFORARDNPDU = 4
  define int BVLCISTATUSEND = 5

  define Str NPCIRANGE = "Disable, Enable, END"
  define int DNETDISABLE = 0
  define int DNETENABLE = 1
  
  define int SNETDISABLE = 0
  define int SNETENABLE = 1
  
  define int DATAREPLYDISABLE = 0
  define int DATAREPLYENABLE = 1
  
  define int NPCIEND = 2

  
  define Str COMMUNICATIONMETHOD = "None, InstanceNumber, SubNetAndMAC, END"
  define int COMMUNICATIONNONE       = 0
  define int COMMUNICATIONBYINSTANCE = 1
  define int COMMUNICATIONBYSUBNET   = 2
  define int COMMUNICATIONEND = 3
  // Lujiaming add these end at 23/05/22
  
  @config
  @defaultOnClone
  @unit = Units.millisecond
  @min = 100
  property int refreshTime = 500

  @readonly
  @unit = Units.millisecond
  property int elapsedTime = -1

  // dataExpectingReplyNPCI
  @range=COMMUNICATIONMETHOD
  @readonly property int communicationMethod = COMMUNICATIONNONE   

  // InstanceNumber
  @asStr
  @config
  property Buf(64) InstanceNumber = ""

  ////////////////////////////////////////////////////////////////
  // Life cycle
  ////////////////////////////////////////////////////////////////
  override void loaded()
  {
    update()
  }
  override void changed(Slot slot)
  {
    super.changed(slot)
    if (slot == bacDevice.deviceName || slot == bacDevice.refreshTime) {
      update()
    }
  }
  override void stop()
  {
    status := STATUSEND
    Component n = Sys.app.lookup(parent)
    if (n.type.is(FieldBusNet.type)) {
      ((FieldBusNet)n).update()
      ((FieldBusNet)n).notifyFlush()
    }
  }

  ////////////////////////////////////////////////////////////////
  // App support
  ////////////////////////////////////////////////////////////////
  void update()
  {
    if (bus != null) {
        if(bus.type.is(BIP.type))
        {
            ((BIP)bus).updateCache()
        }
    }
    log.message("bacDevice update 1111 status=$status") 
    for (Component d = Sys.app.lookup(children); d != null; d = Sys.app.lookup(d.nextSibling)) {
         if(((BacNetFieldBusIO)d).device == null)
         {
            ((BacNetFieldBusIO)d).device = this
         }
         ** log.message("bacDevice update 22222 status=$status") 
    } 
    createRPMAndWPM()
    log.message("bacDevice update 3333 status=$status") 
  }

  override void execute()
  {
    ** log.message("bacDevice execute 11111 status=$status") 
    if (bus != null) {
        if (bus.needFlush == false) {
            dataLength = readReg(0, 0, 1024, buf)
            if(dataLength > 0)
            {
                ** log.message("We readReg and return $dataLength from ${dataRecvGramAddr}")
                for(int i =0 ; i < dataLength; i++)
                {
                    //    log.message(
                    //        "execute readReg (0x").printHex(
                    //            (byte)buf[i]).print(") .").nl()
                    bacnetRecvPacket[i] = (byte)buf[i]
                }
                // objectIdentifier = sourceNetworkAddress = -1
                int iRet = checkReadData(bacnetRecvPacket, dataLength)
                if(iRet == 0)
                {
                   log.message("We readReg and return (${objectIdentifier}, ${sourceNetworkAddress})")
                   log.message("          from ${dataRecvGramAddr}")
                //   objectIdentifier = 240012
                //   dataRecvGramAddr = "192.168.168.241"

                   log.message("We use ${objectIdentifier} temply")
                   setClientAddress(dataRecvGramAddr)
                }
            }
            
            ** log.message("Setting communicationMethod with ($lastInstanceNumber, $InstanceNumber)")
            if(lastInstanceNumber.toStr().equals(InstanceNumber.toStr()) == false)
            {
               bacnet_close(0)
               getBacnetCurrentDevice()
               openPort(true)
            }
         
        }
        else 
        {
            log.message("We needFlush ")
        }
        // 
        ** log.message("bacDevice execute 33333 status=$status")
        if(execute_mode == BACNET_PROPERTY_READ)
        {
            for (Component d = Sys.app.lookup(children); d != null; d = Sys.app.lookup(d.nextSibling)) {
                // ((BacNetFieldBusIO)d).device = this
                // d.execute()
                ** log.message("READ::execute_mode = $execute_mode and execute_counter= $execute_counter ")
                if (d.type.is(BacReadPropertyVar.type))  {
                   ((BacReadPropertyVar)d).execute()
                } else if (d.type.is(bacReadPropertyMultiple.type))  {
                   ((bacReadPropertyMultiple)d).execute()
                }
            }
            execute_counter = execute_counter + 1
            if(execute_counter == BACNET_PROPERTY_READ_EXECUTE_TIMES)
            {
                execute_counter = 0
                execute_mode    = BACNET_PROPERTY_WRITE
            }
        }
        else if(execute_mode == BACNET_PROPERTY_WRITE)
        {
            for (Component d = Sys.app.lookup(children); d != null; d = Sys.app.lookup(d.nextSibling)) {
                // ((BacNetFieldBusIO)d).device = this
                // d.execute()
                ** log.message("WRITE::execute_mode = $execute_mode and execute_counter= $execute_counter ")
                if (d.type.is(bacWriteProperty.type))  {
                   ((bacWriteProperty)d).execute()
                } 
            }
            execute_counter = execute_counter + 1
            if(execute_counter == BACNET_PROPERTY_WRITE_EXECUTE_TIMES)
            {
                execute_counter = 0
                execute_mode    = BACNET_PROPERTY_READ
            }
        }
        else
        {
            log.message("ERROR: execute_mode = $execute_mode ")
        }
    }
    else
    {
       log.message("bus is null ")
    }
  }
  
  int fillHead()
  {
      log.message("fillHead start")
    // BACnet Virtual Link Control
    // Type: BACnet/IP (Annex J) (0x81)
    bacnetPacket[0] = 0x81
    if(typeBVLCI == BVLCISTATUSDISTRIBUTEBROADCAST)
    {   
      bacnetPacket[1] = 0x9
    }
    else if(typeBVLCI == BVLCISTATUSUNICAST)
    {   
      // Function: Original-Unicast-NPDU (0x0a)
      bacnetPacket[1] = 0xA
    }
    else if(typeBVLCI == BVLCISTATUSBROADCAST)
    {   
      bacnetPacket[1] = 0xB
    }
    else 
    {   
      log.message("fillHead error typeBVLCI")
      return -1
    }
    // Skip BVLC-Length: 4 of 18 bytes BACnet packet length
    bacnetPacket[2] = 0x00
    bacnetPacket[3] = 0x00
    // Building Automation and Control Network NPDU
    // NPCI Version: 0x01 (ASHRAE 135-1995)
    bacnetPacket[4] = versionNPCI
    log.message("fillHead::communicationMethod send communicationMethod =${communicationMethod}")
    // Control: 0x04, Expecting Reply
    if(communicationMethod == COMMUNICATIONBYSUBNET)
    {
        bacnetPacket[5] = 0x20
        // Building Automation and Control Network APDU
        bacnetPacket[5] += 0x04
        bacnetPacket[5] += priorityNPCI
        // dnetNPCI
        bacnetPacket[6] = sourceNetworkAddress/256
        bacnetPacket[7] = sourceNetworkAddress%256
        log.message("fillHead::COMMUNICATIONBYSUBNET send sourceNetworkAddress =${sourceNetworkAddress}")
    //  // Destination MAC Layer Address Length: 1
    //  bacnetPacket[8] = 0x01
    //  // DADR: 5
    //  log.message("send DADR =$sadr")
    //  bacnetPacket[9] = sadr
        // Destination MAC Layer Address Length: 0
        if(sadr == 0)
        {
           bacnetPacket[8] = 0x00
        }
        else
        {
           bacnetPacket[8] = 0x01
           bacnetPacket[9] = sadr
        }
        // hopCountNPCI
        bacnetPacket[10] = hopCountNPCI
        return 11
    }
    else if(communicationMethod == COMMUNICATIONBYINSTANCE)
    {   
        log.message("fillHead::COMMUNICATIONBYINSTANCE send ")
        bacnetPacket[5] = 0x00
        bacnetPacket[5] += 0x04
        return 6
    }
    else 
    {   
      log.message("Error dataExpectingReplyNPCI with (${sourceNetworkAddress}, ${sadr})") 
      return -1
    }
  }

  override int writeReg(int deviceAddr, int addr, int iLen, float[] buf)
  { 
    int headLength = 0
    log.message("writeReg headLength=$headLength") 
    headLength = fillHead()
    if(headLength == -1)
        return headLength
    log.message("writeReg headLength=$headLength") 
    bacnetPacket[2] = (headLength + iLen)/256
    bacnetPacket[3] = (headLength + iLen)%256

    for(int i =0; i < headLength; i++)
    {
       bufToBIP[i] = (float)bacnetPacket[i]
    }
    
    for(int j =0; j < iLen; j++)
    {
       bufToBIP[j + headLength] = buf[j]
    }
    int iRet = writeBusReg(deviceAddr, addr, iLen + headLength, bufToBIP)
    return iLen
  }


  int checkBacnetHead()
  {
    int packetLength = 0
    if(dataRecvGram.buf[0] != 0x81)
      return -1
    packetLength = dataRecvGram.buf[2] * 256 + dataRecvGram.buf[3]
    
    ** log.message("packetLength = $packetLength and dataRecvGram.len=${dataRecvGram.len}")
    if(packetLength != dataRecvGram.len)
      return -1
    return 0
  }

  int readReg(int deviceAddr, int addr, int iLen, float[] buf)
  {
    int headLength = 0
    dataRecvGram.len = iLen
    dataRecvGram.buf = packetRecv.bytes
    if (socket.isClosed())
    { 
      if (socket.open() == false)
      { 
         log.warning("cannot open socket")
         return -1
      }
    }
    bool bRet = socket.receive(dataRecvGram)
    if (bRet == false) 
    {
       ** log.message("readReg failed with len=${dataRecvGram.len} and port=${dataRecvGram.port} ")
       return -1
    }
    ** log.message("socket.receive($iLen) ${dataRecvGram.len} bytes from ${dataRecvGram.addr.toStr()}")
    dataRecvGramAddr = dataRecvGram.addr.toStr()
    headLength = checkBacnetHead()
    if(headLength < 0)
    {
       log.message("checkBacnetHead failed")
       return -1
    }

    
    for(int i =headLength; i < dataRecvGram.len; i++)
    {
       buf[i] = (float)dataRecvGram.buf[i]
    }
    return dataRecvGram.len
  }

  void output_hex(byte[] bytePacket, int iPacketLen)
  {
     Str strHexByte;
     for(int i =0 ; i < iPacketLen; i++)
     {
       strHexByte = Sys.hexStr(bytePacket[i])
       ** log.message("output_hex strHexByte='$strHexByte' with $iPacketLen ")
     }
  }

  int writeBusReg(int deviceAddr, int addr, int iLen, float[] buf)
  { 
    // Init sockReadAddr
    sockReadAddr.addr.parse("0.0.0.0")
    sockReadAddr.port = 0
    dataSendGram.getSocketAddr(sockReadAddr)
    // Get Addr and port from dataSendGram
    if(sockReadAddr.port == 0)
    {
       log.message("111111 writeReg")
       return -1;
    }
    ** log.message("22222 writeReg with sockReadAddr.port=${sockReadAddr.port}")
    ** log.message("22222 writeReg with sockReadAddr.addr=${sockReadAddr.addr.toStr()}")
    
    for(int i =0; i < iLen; i++)
    {
       bacnetPacket[i] = (byte)buf[i]
    }

    output_hex(bacnetPacket, iLen)
    // Copy head
    packetSend.copyFromBytes(bacnetPacket, 0, iLen)
    ** log.message("Copy body ${iLen}")
    dataSendGram.len = iLen
    ** log.message("send dataSendGram.len =${dataSendGram.len}")
    dataSendGram.buf = packetSend.bytes
    if(dataSendGram.len > 0)
    {
       forwardToVTS(dataSendGram.buf, dataSendGram.len)
    }
    return socket.send(dataSendGram)?iLen:0
  }

  // For debug
  int forwardToVTS(byte[] bacnetRecvPacket, int iPacketLen)
  {
    addrSendVTS.addr.parse("192.168.168.180")
    addrSendVTS.port = ((BIP)bus).port
    dataVTSForwardSendGram.setSocketAddr(addrSendVTS)
    dataVTSForwardSendGram.len = iPacketLen
    ** log.message("send dataVTSForwardSendGram.len =${dataVTSForwardSendGram.len}")
    dataVTSForwardSendGram.buf = bacnetRecvPacket
    return socket.send(dataVTSForwardSendGram)?iPacketLen:0
  }
  

  int checkAPNUData(int apduType)
  {
    if(apduType == 0x00)
    {
       log.message("BACnet-Confirmed-Request-PDU")
       return 0
    }
    else if(apduType == 0x01)
    {
       log.message("BACnet-Unconfirmed-Request-PDU")
       return 0
    }
    else if(apduType == 0x02)
    {
       log.message("BACnet-SimpleACK-PDU")
       return 0
    }
    else if(apduType == 0x03)
    {
       log.message("BACnet-ComplexACK-PDU")
       return 1
    }
    else if(apduType == 0x04)
    {
       log.message("BACnet-SegmentACK-PDU")
       return 0
    }
    else if(apduType == 0x05)
    {
       log.message("BACnet-Error-PDU")
       return 0
    }
    else if(apduType == 0x06)
    {
       log.message("BACnet-Reject-PDU")
       return 0
    }
    else if(apduType == 0x07)
    {
       log.message("BACnet-Abort-PDU")
       return 0
    }
    else 
    {
       log.message("Unknown apduType ")
       return 0
    }
  }

  int checkReadData(byte[] bacnetRecvPacket, int iPacketLen)
  {
    int bacnetPacketLen = bacnetRecvPacket[2] * 256 + bacnetRecvPacket[3]
    ** log.message("bacnetPacketLen = ${bacnetPacketLen} and iPacketLen =${iPacketLen} ")
    ** log.message("with bacnetRecvPacket[2]=0x").printHex(bacnetRecvPacket[2]).print(". ").nl()
    ** log.message("with bacnetRecvPacket[3]=0x").printHex(bacnetRecvPacket[3]).print(". ").nl()
    if(bacnetPacketLen != iPacketLen)
    {
       log.message("ERROR: bacnetPacketLen = ${bacnetPacketLen} and iPacketLen =${iPacketLen}")
       return -1
    }
    forwardToVTS(bacnetRecvPacket, iPacketLen)
    // BACnet Virtual Link Control
    int serviceChoicePos = 4
    // ex: Control: 0x25, Destination Specifier, Expecting Reply, Priority
    serviceChoicePos += 2
    
    // DNET, DLEN, DAD R&Hop Count Present
    int dnetSupport = bacnetRecvPacket[5] & 0x20
    if(dnetSupport == 0x20)
    {
      serviceChoicePos += 4
    }
    
    // SNET, SLEN, &SADR Present 
    int snetSupport = bacnetRecvPacket[5] & 0x08
    if(snetSupport == 0x08)
    {
      if(dnetSupport == 0x20)
      {
          sourceNetworkAddress = bacnetRecvPacket[9] * 256 + bacnetRecvPacket[10]
          // bacnetRecvPacket[11] is Source MAC Layer Address Length: 1
          // sadr                 = bacnetRecvPacket[12]
      }
      else
      {
          sourceNetworkAddress = bacnetRecvPacket[6] * 256 + bacnetRecvPacket[7]
          // bacnetRecvPacket[8] is Source MAC Layer Address Length: 1
          // sadr                 = bacnetRecvPacket[9]
      }
      ** log.message("sourceNetworkAddress is ${sourceNetworkAddress} ")
      ** log.message("sadr is ${sadr} ")
      serviceChoicePos += 4
    }
    
    // APDU Type
    int apduType = bacnetRecvPacket[serviceChoicePos] & 0x70
    apduType = apduType / 0x10
    ** log.message("apduType is $apduType ")
    serviceChoicePos += 1
    // 0000 .... = APDU Type: Confirmed-REQ (0)
    if(apduType == 0)
    {
       serviceChoicePos += 1
       log.message("Invoke ID is ${bacnetRecvPacket[serviceChoicePos]} ")
       serviceChoicePos += 1
    }
    // readProperty have Max Response Segments accepted: Unspecified (0)
    int apduTypeExtraLength = checkAPNUData(apduType)
    serviceChoicePos += apduTypeExtraLength

    ** log.message("Service Choice is ${bacnetRecvPacket[serviceChoicePos]} ")
    int objectIdentifierAndType = 0
    // ex: Service Choice: read Property (12)
    // ex: Service Choice: read Property ACK (12)
    if(bacnetRecvPacket[serviceChoicePos] == 0x0C)
    {
        if (apduTypeExtraLength == 0)
        {
           log.message("Service Choice: read Property ")
        }
        else if (apduTypeExtraLength == 1)
        {
           log.message("Service Choice: read Property ACK")
        }
        else 
        {
           log.message("Service Choice: Illegal read Property and apduTypeExtraLength =${apduTypeExtraLength}")
           return -1
        }
        // log.message("Service Choice: read Property ")
        // return 0
        
        serviceChoicePos++
        // Context Tag: 0, Length/Value/Type: 4
        int iObjectType = bacnetRecvPacket[serviceChoicePos] & 0x07
        log.message("LengthValueType = ${iObjectType} ")
        serviceChoicePos += 2
        int iInstanceNumber = bacnetRecvPacket[serviceChoicePos] * 0x10000 
                            + bacnetRecvPacket[serviceChoicePos + 1] * 0x100
                            + bacnetRecvPacket[serviceChoicePos + 2]
        serviceChoicePos += 3
        // Instance Number: 99
        log.message("Instance Number = $iInstanceNumber ")
        // Property Identifier : Length Value Type: 1
        int PropertyLengthValue = bacnetRecvPacket[serviceChoicePos] & 0x03
        log.message("PropertyLengthValue = ${PropertyLengthValue} ")
        
        // int  propertyProperty = 0x00
        // Include SD Context Tag
        // int  propertyProperty = bacnetRecvPacket[serviceChoicePos]
        // log.message("Start propertyProperty = 0x").printHex(propertyProperty).print(". ").nl()
        int  propertyProperty = 0
        serviceChoicePos++
        
        for(int i = 0 ; i < PropertyLengthValue; i++)
        {
           propertyProperty = propertyProperty * 0x100
                               + bacnetRecvPacket[serviceChoicePos + i]
           ** log.message("propertyProperty[").printInt(i).print("] = 0x").printHex(
           **                  bacnetRecvPacket[serviceChoicePos + i]).print(". ").nl()
        }
        log.message("End propertyProperty = 0x").printHex(propertyProperty).print(". ").nl()
        serviceChoicePos += PropertyLengthValue
        // We have <property Array Index (Unsigned) 8>
        if(bacnetRecvPacket[serviceChoicePos] != 0x3E)
        {
           serviceChoicePos += 2;
        }
        if(bacnetRecvPacket[serviceChoicePos] != 0x3E)
        {
           log.message("ERROR: Can not find start Tag ")
        }
        
        // .... .110 = Named Tag: Opening Tag (6)
        log.message("Opening Tag = ${bacnetRecvPacket[serviceChoicePos]} ")
        serviceChoicePos++
        int tagNumber = bacnetRecvPacket[serviceChoicePos]
        log.message("Old tagNumber=$tagNumber")
        while (tagNumber != 0x3F)
        {
            tagNumber = tagNumber/0x10
            int iLen = bacnetRecvPacket[serviceChoicePos] % 0x10
            log.message("iLen = $iLen and tagNumber=$tagNumber")
            serviceChoicePos++
            serviceChoicePos = decode_one_tag(bacnetRecvPacket, serviceChoicePos, 
                                                propertyProperty, iObjectType, iInstanceNumber, tagNumber, iLen)
            if(serviceChoicePos == -1)
            {
               log.message("34343434 Error serviceChoicePos ")
               return -1
            }
            tagNumber = bacnetRecvPacket[serviceChoicePos]
        }
        log.message("End of checkReadData .")
        return serviceChoicePos
    }
    else if(bacnetRecvPacket[serviceChoicePos] == 0x00)
    {
        log.message("Service Choice: WhoAmI and bacnetPacketLen = ${bacnetPacketLen}")
        // Application Tag: BACnetObjectIdentifier, Length/Value/Type: 4
        // bacnetRecvPacket[serviceChoicePos + 1] 
        if(bacnetPacketLen == 25)
        {
            objectIdentifierAndType = bacnetRecvPacket[serviceChoicePos + 2]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 3]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 4]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 5]
        }
        else if(bacnetPacketLen == 29)
        {
            objectIdentifierAndType = bacnetRecvPacket[serviceChoicePos + 2]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 3]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 4]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 5]
        }
        else
        {
            objectIdentifierAndType = bacnetRecvPacket[serviceChoicePos + 2]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 3]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 4]
            objectIdentifierAndType = objectIdentifierAndType * 0x100 + 
                                      bacnetRecvPacket[serviceChoicePos + 5]
        }
        log.message("objectIdentifierAndType = ${objectIdentifierAndType}")
        objectIdentifier = objectIdentifierAndType % 0x400000
        log.message("BIP::objectIdentifier = ${objectIdentifier}")
        return 0
    }
    else if(bacnetRecvPacket[serviceChoicePos] == 0x09)
    {
        log.message("return BACnet-Abort-PDU")
        return -1
    }
    // Service Choice: readPropertyMultiple (14)
    else if(bacnetRecvPacket[serviceChoicePos] == 0x0E)
    {
        // ObjectIdentifier: analog-value, 0
        serviceChoicePos++
        while (serviceChoicePos < iPacketLen)
        {
            log.message("00000 bacnetRecvPacket[serviceChoicePos] = 0x").printHex(bacnetRecvPacket[serviceChoicePos]).print(". ").nl()
            int iObjectIdentifierLen = bacnetRecvPacket[serviceChoicePos] & 0x07
            log.message("iObjectIdentifierLen = ${iObjectIdentifierLen}  ")
            serviceChoicePos++
            
            int iObjectIdentifier = 0
            for(int i = 0 ; i < iObjectIdentifierLen; i++)
            {
               iObjectIdentifier = iObjectIdentifier * 0x100
                                   + bacnetRecvPacket[serviceChoicePos + i]
            }
            ** log.message("00011 iObjectIdentifier = 0x").printHex(iObjectIdentifier).print(". ").nl()
            // 0000 0000 10.. .... .... .... .... .... = Object Type: analog-value (2)
            int iObjectType = iObjectIdentifier/0x400000
            // .... .... ..00 0000 0000 0000 0000 0000 = Instance Number: 0
            int iInstanceNumber = iObjectIdentifier % 0x400000
            log.message("iObjectType = ${iObjectType} and iInstanceNumber = ${iInstanceNumber} ")
            serviceChoicePos += iObjectIdentifierLen
            log.message("11111 bacnetRecvPacket[serviceChoicePos] = 0x").printHex(bacnetRecvPacket[serviceChoicePos]).print(". ").nl()
            if(bacnetRecvPacket[serviceChoicePos] != 0x1E)
            {
               log.message("bacnetRecvPacket Error Opening Tag")
               return -1
            }
            serviceChoicePos++
            // Property Identifier : Length Value Type: 1
            int PropertyLengthValue = bacnetRecvPacket[serviceChoicePos] & 0x03
            log.message("PropertyLengthValue = ${PropertyLengthValue} ")
            
            int  propertyProperty = 0
            serviceChoicePos++
            for(int i = 0 ; i < PropertyLengthValue; i++)
            {
               propertyProperty = propertyProperty * 0x100
                                   + bacnetRecvPacket[serviceChoicePos + i]
               ** log.message("propertyProperty[").printInt(i).print("] = 0x").printHex(
               **                  bacnetRecvPacket[serviceChoicePos + i]).print(". ").nl()
            }
            log.message("----------------- We Get propertyProperty = ${propertyProperty} ")
            serviceChoicePos += PropertyLengthValue
            ** log.message("22222 bacnetRecvPacket[serviceChoicePos] = 0x").printHex(bacnetRecvPacket[serviceChoicePos]).print(". ").nl()
            if(bacnetRecvPacket[serviceChoicePos] != 0x4E)
            {
               log.message("Error tag ")
               return -1
            }
            serviceChoicePos++
            int tagNumber = bacnetRecvPacket[serviceChoicePos]
            while (tagNumber != 0x3F)
            {
                tagNumber = tagNumber/0x10
                int iLen = bacnetRecvPacket[serviceChoicePos] % 0x10
                log.message("33333 iLen = $iLen and tagNumber=$tagNumber")
                serviceChoicePos++
                serviceChoicePos = decode_one_tag(bacnetRecvPacket, serviceChoicePos, 
                                        propertyProperty, iObjectType, iInstanceNumber, tagNumber, iLen)
                if(serviceChoicePos == -1)
                {
                   log.message("34343434 Error serviceChoicePos ")
                   return -1
                }
                log.message("444444 bacnetRecvPacket at $serviceChoicePos")
                log.message("444444 bacnetRecvPacket[$serviceChoicePos] = 0x").printHex(bacnetRecvPacket[serviceChoicePos]).print(". ").nl()
                if(bacnetRecvPacket[serviceChoicePos] != 0x4F)
                {
                   log.message("Error Closing Tag")
                   return -1
                }
                serviceChoicePos++
                log.message("45454545 bacnetRecvPacket[serviceChoicePos] = 0x").printHex(bacnetRecvPacket[serviceChoicePos]).print(". ").nl()
                if (bacnetRecvPacket[serviceChoicePos] == 0x1F)
                {
                   log.message("We meet the end of this packet ")
                   serviceChoicePos++
                   break;
                }
                tagNumber = bacnetRecvPacket[serviceChoicePos]

                // Property Identifier
                log.message("We meet a Property Identifier with 0x").printHex(bacnetRecvPacket[serviceChoicePos]).print(". ").nl()
                PropertyLengthValue = bacnetRecvPacket[serviceChoicePos] & 0x03
                log.message("PropertyLengthValue = ${PropertyLengthValue} ")
                
                propertyProperty = 0
                serviceChoicePos++
                for(int i = 0 ; i < PropertyLengthValue; i++)
                {
                   propertyProperty = propertyProperty * 0x100
                                       + bacnetRecvPacket[serviceChoicePos + i]
                   ** log.message("propertyProperty[").printInt(i).print("] = 0x").printHex(
                   **                  bacnetRecvPacket[serviceChoicePos + i]).print(". ").nl()
                }
                log.message("-----------------  Get next propertyProperty = ${propertyProperty} ")
                serviceChoicePos += PropertyLengthValue
                log.message("5555555 bacnetRecvPacket[serviceChoicePos] = 0x").printHex(bacnetRecvPacket[serviceChoicePos]).print(". ").nl()

                // Error Property Identifier
                if(bacnetRecvPacket[serviceChoicePos] == 0x5E)
                {
                    serviceChoicePos++
                    // error Class:  property
                    int iErrorClassPropertyLen = bacnetRecvPacket[serviceChoicePos] % 0x10
                    serviceChoicePos++
                    serviceChoicePos += iErrorClassPropertyLen
                    // error Code:  unknown-property
                    int iErrorCodePropertyLen = bacnetRecvPacket[serviceChoicePos] % 0x10
                    serviceChoicePos++
                    serviceChoicePos += iErrorCodePropertyLen
                }
                // Property Identifier
                else if(bacnetRecvPacket[serviceChoicePos] == 0x4E)
                {
                   serviceChoicePos++
                   log.message("6666 bacnetRecvPacket[serviceChoicePos] = 0x").printHex(bacnetRecvPacket[serviceChoicePos]).print(". ").nl()
                   tagNumber = bacnetRecvPacket[serviceChoicePos]
                   // We goto the start of this cycle to get the next property
                   continue
                }
                
                // When we arrive here we are at the end of Property Identifier List
                if(bacnetRecvPacket[serviceChoicePos] == 0x5F)
                {
                   serviceChoicePos++
                   log.message("End of Property Identifier List")
                   serviceChoicePos++
                   // We have to quit the cycle of Property Identifier List
                   break
                }
                else 
                {
                   log.message("bacnetRecvPacket[serviceChoicePos] Error Opening Tag")
                   return -1
                }
            }
        }
        log.message("77777 End of checkReadData. ")
        return serviceChoicePos
    }
    else
    {
        log.message("Service Choice: bacnetRecvPacket =${bacnetRecvPacket[serviceChoicePos]} ")
        for(int i =0 ; i < iPacketLen; i++)
        {
            log.message("checkReadData read 0x").printHex(bacnetRecvPacket[i]).print(". ").nl()
        }
       return -1
    }
  }

  int decode_one_tag(byte[] bacnetRecvPacket, int iChoicePos, 
                              int propertyProperty, int iObjectType, int iInstanceNumber, 
                              int tagNumber, int iOutLen)
  {
    int serviceChoicePos = iChoicePos;
    int iLen = iOutLen;
    // link_type = Component.LINK_TYPE_READ + tagNumber
    switch (tagNumber)
    {
        case BacNetFieldBusIO.BANET_PROPVAR_BOOLEANAPPTAG:
            bufData[0] = iLen
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, 1)
            break
        case BacNetFieldBusIO.BANET_PROPVAR_ENUMERATEDAPPTAG:
        case BacNetFieldBusIO.BANET_PROPVAR_OBJECTIDENTIFIERAPPTAG:
        case BacNetFieldBusIO.BANET_PROPVAR_UNSIGNEDINTAPPTAG:
            for (int i = 0; i < iLen; i++)
            {
               bufData[i] = bacnetRecvPacket[serviceChoicePos + i]
            }
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, iLen)
            serviceChoicePos += iLen
            break
        case BacNetFieldBusIO.BANET_PROPVAR_INTEGERAPPTAG:
            for (int i = 0; i < iLen; i++)
            {
               bufData[i] = bacnetRecvPacket[serviceChoicePos + i]
            }
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, iLen)
            serviceChoicePos += iLen
            break
        case BacNetFieldBusIO.BANET_PROPVAR_REALAPPTAG:
            for (int i = 0; i < iLen; i++)
            {
               bufData[i] = bacnetRecvPacket[serviceChoicePos + i]
            }
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, iLen)
            serviceChoicePos += iLen
            break
        case BacNetFieldBusIO.BANET_PROPVAR_DOUBLEAPPTAG:
            iLen = bacnetRecvPacket[serviceChoicePos]
            log.message("iLen fix to ${iLen} ")
            serviceChoicePos++
            for (int i = 0; i < iLen; i++)
            {
               bufData[i] = bacnetRecvPacket[serviceChoicePos + i]
            }
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, iLen)
            serviceChoicePos += iLen
            break
        case BacNetFieldBusIO.BANET_PROPVAR_BITSTRINGAPPTAG:
            serviceChoicePos += iLen
            break
        case BacNetFieldBusIO.BANET_PROPVAR_OCTETSTRINGAPPTAG:
            iLen = bacnetRecvPacket[serviceChoicePos] 
            log.message("OCTETSTRINGAPPTAG.iLen = $iLen ")
            serviceChoicePos++

            for (int i = 0; i < iLen; i++)
            {
               strInfo.set(i, bacnetRecvPacket[serviceChoicePos + i])
               bufData[i] = bacnetRecvPacket[serviceChoicePos + i]
            }
            strInfo.set(iLen, '\0')
            ** log.message("bacDevice::decode_one_tag Character string = $strInfo ")
            
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, iLen)
            serviceChoicePos += iLen
            break
        case BacNetFieldBusIO.BANET_PROPVAR_CHARACTERSTRINGAPPTAG:
            iLen = bacnetRecvPacket[serviceChoicePos] 
            ** log.message("CHARACTERSTRINGAPPTAG.iLen = $iLen ")
            serviceChoicePos++
            // Jump over : ASCII/UTF-8 Character Encoding = 0
            serviceChoicePos++
            iLen = iLen - 1
            
            for (int i = 0; i < iLen; i++)
            {
               ** log.message("bacnetPacketLen = $bacnetPacketLen and we get ${serviceChoicePos} ")
               strInfo.set(i, bacnetRecvPacket[serviceChoicePos + i])
               bufData[i] = bacnetRecvPacket[serviceChoicePos + i]
            }
            strInfo.set(iLen, '\0')
            ** log.message("bacDevice::decode_one_tag Character string = $strInfo ")
            
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, iLen)
            serviceChoicePos += iLen
            break
        case BacNetFieldBusIO.BANET_PROPVAR_DATEAPPTAG:
            log.message("year = ${bacnetRecvPacket[serviceChoicePos]}  ")
            bufData[0] = bacnetRecvPacket[serviceChoicePos]
            serviceChoicePos++
            log.message("month = ${bacnetRecvPacket[serviceChoicePos]} ")
            bufData[1] = bacnetRecvPacket[serviceChoicePos]
            serviceChoicePos++
            log.message("year = ${bacnetRecvPacket[serviceChoicePos]}  ")
            bufData[2] = bacnetRecvPacket[serviceChoicePos]
            serviceChoicePos++
            log.message("month = ${bacnetRecvPacket[serviceChoicePos]} ")
            bufData[3] = bacnetRecvPacket[serviceChoicePos]
            serviceChoicePos++
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, 4)
            break
        case BacNetFieldBusIO.BANET_PROPVAR_TIMEAPPTAG:
            log.message("hour = ${bacnetRecvPacket[serviceChoicePos]}  ")
            bufData[0] = bacnetRecvPacket[serviceChoicePos]
            serviceChoicePos++
            log.message("minute = ${bacnetRecvPacket[serviceChoicePos]} ")
            bufData[1] = bacnetRecvPacket[serviceChoicePos]
            serviceChoicePos++
            log.message("second = ${bacnetRecvPacket[serviceChoicePos]}  ")
            bufData[2] = bacnetRecvPacket[serviceChoicePos]
            serviceChoicePos++
            log.message("hundredths = ${bacnetRecvPacket[serviceChoicePos]} ")
            bufData[3] = bacnetRecvPacket[serviceChoicePos]
            serviceChoicePos++
            bus.setBacReadPropertyVarByProperty(this, propertyProperty, iObjectType, iInstanceNumber, tagNumber, bufData, 4)
            break
        // case BANET_PROPVAR_RESERVEDAPPTAG13:
        // case BANET_PROPVAR_RESERVEDAPPTAG14:
        // case BANET_PROPVAR_RESERVEDAPPTAG15:
        default:
            log.message("Not support $tagNumber ")
            return -1
    }  
    return serviceChoicePos
  }

  int convertmaxADPU(int imaxADPU)
  {
    // B'0000' Up to MinimumMessageSize (50 octets)
    if(imaxADPU == 50)
       return 0
    // B'0001' Up to 128 octets
    else if(imaxADPU == 128)
       return 1
    // B'0010' Up to 206 octets(fits in a LonTalk frame)
    else if(imaxADPU == 206)
       return 2
    // B'0011' Up to 480 octets(fits in an ARCNET frame)
    else if(imaxADPU == 480)
       return 3
    // B'0100' Up to 1024 octets
    else if(imaxADPU == 1024)
       return 4
    // B'0101' Up to 1476 octets(fits in a ISO 8802-3 frame)
    else if(imaxADPU == 1476)
       return 5
    // It is impossible,we use B'0011' Up to 480 octets as the default value
    else 
       return 3
    // B'0110' reserved by ASHRAE
    // B'0111' reserved by ASHRAE
    // B'1000' reserved by ASHRAE
    // B'1001' reserved by ASHRAE
    // B'1010' reserved by ASHRAE
    // B'1011' reserved by ASHRAE
    // B'1100' reserved by ASHRAE
    // B'1101' reserved by ASHRAE
    // B'1110' reserved by ASHRAE
    // B'1111' reserved by ASHRAE
  }
/*
  int setClientAddressBySNetAndMac(int sNetAddrID, int macID)
  {
    for(int i = 0 ; i < ((BIP)bus).iDeviceCount; i++)
    {
        sourceNetworkAddress = ((BIP)bus).NPDUList[i] % 0x10000
        sadr                 = ((BIP)bus).NPDUList[i] / 0x10000
        if((sourceNetworkAddress == sNetAddrID) && (sadr == macID))
        {
            bufInteger[0] = ((BIP)bus).ipArrayList[i]
            bus.encodeUnsigned(bufInteger, bufData)
            addrClientBuf.copyFromBytes(bufData, 0, 4)
            addrClient.loadBuf(addrClientBuf)
            setClientAddress(addrClient.toStr())
            if((sourceNetworkAddress != 0) && (sadr != 0))
            {
               maxAPDULength = convertmaxADPU(((BIP)bus).maxADPUList[i])
               log.message("maxAPDULength = $maxAPDULength and ClientAddress= ${addrClient.toStr()}")
               log.message("We are Setting communicationMethod into COMMUNICATIONBYSUBNET")
               return 2 // COMMUNICATIONBYSUBNET
            }
         //   else if((sourceNetworkAddress == 0) && (sadr == 0))
         //   {
         //       log.message("Setting communicationMethod to COMMUNICATIONBYINSTANCE")
         //      return 1 // COMMUNICATIONBYINSTANCE
         //   }
            else
            {
                log.message("Error to setting communicationMethod into COMMUNICATIONNONE")
               return 0 // COMMUNICATIONNONE
            }
        }
    }
    log.message("Failed to Setting communicationMethod to COMMUNICATIONNONE")
    return 0 // COMMUNICATIONNONE
  }
  
  int setClientAddressByInstanceNumber(int instanceNumber)
  {
    int iCurrentInstanceNumber = 0;
    for(int i = 0 ; i < ((BIP)bus).iDeviceCount; i++)
    {
        iCurrentInstanceNumber = ((BIP)bus).objectIdentifierList[i] % 0x400000
        if(iCurrentInstanceNumber == instanceNumber)
        {
            bufInteger[0] = ((BIP)bus).ipArrayList[i]
            bus.encodeUnsigned(bufInteger, bufData)
            addrClientBuf.copyFromBytes(bufData, 0, 4)
            addrClient.loadBuf(addrClientBuf)
            setClientAddress(addrClient.toStr())
            sourceNetworkAddress = ((BIP)bus).NPDUList[i] % 0x10000
            sadr                 = ((BIP)bus).NPDUList[i] / 0x10000
            if((sourceNetworkAddress != 0) && (sadr != 0))
            {
               maxAPDULength = convertmaxADPU(((BIP)bus).maxADPUList[i])
               log.message("maxAPDULength = $maxAPDULength and ClientAddress= ${addrClient.toStr()}")
               log.message("Setting communicationMethod to COMMUNICATIONBYSUBNET")
               return 2 // COMMUNICATIONBYSUBNET
            }
            else if((sourceNetworkAddress == 0) && (sadr == 0))
            {
                log.message("Setting communicationMethod to COMMUNICATIONBYINSTANCE")
               return 1 // COMMUNICATIONBYINSTANCE
            }
            else
            {
                log.message("Error to setting communicationMethod to COMMUNICATIONNONE")
               return 0 // COMMUNICATIONNONE
            }
        }
    }
    log.message("Failed to Setting communicationMethod to COMMUNICATIONNONE")
    return 0 // COMMUNICATIONNONE
  }
 */ 
  int setClientAddress(Str ipClientAddress)
  {
    addrSendLocal.addr.parse(ipClientAddress)
    addrSendLocal.port = ((BIP)bus).port
    dataSendGram.setSocketAddr(addrSendLocal)
    return 0
  }

  int makeDevice4194303PropertyIdentifier()
  {
    dataLength = 0
    // 0000 .... = APDU Type: Confirmed-REQ (0)
    bacnetPacket[0] = 0x00
    bacnetPacket[1] = maxAPDULength
    
    // invokeID: Invoke ID: 9
    bacnetPacket[2] = invokeID
    invokeID = invokeID + 1
    if(invokeID == 0xFF)
       invokeID = 0
    dataLength = 3
    // if(segmentedMsg == SEGMENTEDMSGENABLE)
    // {
    //     bacnetPacket[3] = sequenceNumber
    //     bacnetPacket[4] = proposedWindowSize
    //     dataLength = 5
    // }
    // Service Choice: readProperty (12)
    bacnetPacket[dataLength++] = 0x0C
    // Context Tag: 0, Length/Value/Type: 4
    // .... 1... = Tag Class: Context Specific Tag
    // 0000 .... = Context Tag Number: 0
    // Length Value Type: 4
    bacnetPacket[dataLength++] = 0x0C
    // 0000 0010 00.. .... .... .... .... .... = Object Type: device (8)
    int objectNodeType = 8
    if(objectNodeType > 4)
    {
        bacnetPacket[dataLength++] = objectNodeType / 4
    }
    else 
    {
        bacnetPacket[dataLength++] = 0x00
    }
    bacnetPacket[dataLength] = (objectNodeType % 4) * 0x40
    // .... .... ..11 1111 1111 1111 1111 1111 = Instance Number: 4194303
    int instanceNumber = 4194303
    bacnetPacket[dataLength] += 0x3F
    dataLength++
    if(instanceNumber > 0x00)
    {
        bacnetPacket[dataLength++] = instanceNumber / 0x100
    }
    else 
    {
        bacnetPacket[dataLength++] = 0x00
    }
    bacnetPacket[dataLength++] = instanceNumber % 0x100
    log.message("BacReadPropertyVar::instanceNumber = ${instanceNumber}")
    // Property Identifier: object-identifier (75)
    int propertyIdentifier = 75
    log.message("BacReadPropertyVar::propertyIdentifier = $propertyIdentifier")
    bacnetPacket[dataLength++] = 0x18 + 1
    bacnetPacket[dataLength++] = (propertyIdentifier)%0x0100

    log.message("22222 bacnetPacket[$dataLength]")
    for(int i =0 ; i < dataLength; i++)
    {
        buf[i] = (float)bacnetPacket[i]
    }
    return dataLength
  }
  
  int getBacnetCurrentDevice()
  {
       bool isSubNetMac = false
       Str sNetBuf = ""
       Str macBuf  = ""
       for (int i=0; i<InstanceNumber.toStr().length(); i++) {
          int c = InstanceNumber.toStr().get(i)
          if (c == "/".get(0)) {
             isSubNetMac = true
             sNetBuf.copyFromStr(InstanceNumber.toStr(), i+1);
             macBuf = InstanceNumber.toStr().suffix(i + 1)
             log.message("-------Get with ($sNetBuf, $macBuf)--------------")
             break
          }
       }  
       if(isSubNetMac) {
            int iRouterDeviceCount = socketDetect.getBacnetRouterDevice((((BIP)bus).ipLocalAddress).bytes, 
                                sNetBuf.parseInt(), 
                                ipRouterArrayList, networkNumberList)
     
            log.message("iRouterDeviceCount = $iRouterDeviceCount")
            if(iRouterDeviceCount > 0)
            {
                bufInteger[0] = ipRouterArrayList[0]
                bus.encodeUnsigned(bufInteger, bufData)
                addrClientBuf.copyFromBytes(bufData, 0, 4)
                addrClient.loadBuf(addrClientBuf)
                setClientAddress(addrClient.toStr())
                log.message("addrClient.toStr() = ${addrClient.toStr()}")

                sourceNetworkAddress = sNetBuf.parseInt()
                log.message("SubNetMac::sourceNetworkAddress = $sourceNetworkAddress")
                sadr                 = macBuf.parseInt()
                log.message("SubNetMac::sadr = $sadr")
                
                communicationMethod := COMMUNICATIONBYSUBNET
            }
            else
            {
                log.message("-------getBacnetRouterDevice Failed--------------")
            }
            lastInstanceNumber.copyFromBuf(InstanceNumber)
            return 2
       }
       else {
            int iDeviceCount = socketDetect.getBacnetDevice((((BIP)bus).ipLocalAddress).bytes, 
                                InstanceNumber.toStr().parseInt(), 
                                ipArrayList, controlDstSpecList, 
                                NPDUList, objectIdentifierList, 
                                maxADPUList)
                         
            if(iDeviceCount > 0)
            {
                bufInteger[0] = ipArrayList[0]
                bus.encodeUnsigned(bufInteger, bufData)
                addrClientBuf.copyFromBytes(bufData, 0, 4)
                addrClient.loadBuf(addrClientBuf)
                setClientAddress(addrClient.toStr())

                sourceNetworkAddress = NPDUList[0] % 0x10000
                log.message("InstanceNumber::sourceNetworkAddress = $sourceNetworkAddress")
                sadr                 = NPDUList[0] / 0x10000
                log.message("InstanceNumber::sadr = $sadr")
                if((sourceNetworkAddress != 0) && (sadr != 0))
				{
					communicationMethod := COMMUNICATIONBYSUBNET
				}
				else if((sourceNetworkAddress == 0) && (sadr == 0))
				{
					communicationMethod := COMMUNICATIONBYINSTANCE
				}
            }
            else
            {
                log.message("-------getBacnetDevice Failed--------------")
            }
            
            lastInstanceNumber.copyFromBuf(InstanceNumber)
            return 1
       }
  }

  **
  ** Open the UDP port using the configured port field.
  ** Return true on success.
  **
  override bool openPort(bool logError)
  { 
    log.message("openPorts")
    if (socket.isClosed() && !socket.open())
    {
      if (logError) log.warning("cannot open socket")
      return false
    }
    log.message("socket.open")

    if (!socket.bind(((BIP)bus).port))
    {
      if (logError) log.error("cannot bind to port=${((BIP)bus).port}")
      return false
    }

    log.message("started port=${((BIP)bus).port}")

    if (socket.join())
      log.message("DASP Discovery enabled")
    else
      log.message("DASP Discovery not enabled")

    Sys.app.platform.notify("BIP", Sys.intStr(((BIP)bus).port))

    // addrSendLocal.addr.parse("0.0.0.0")
    // addrSendLocal.port = 0
    dataSendGram.setSocketAddr(addrSendLocal)
    
    addrRecvLocal.addr.parse(((BIP)bus).ipLocalAddress.toStr())
    addrRecvLocal.port = ((BIP)bus).port
    dataRecvGram.setSocketAddr(addrRecvLocal)

    if(bacnetCurrentDeviceRet == 2)
    {
        log.message("Send makeDevice4194303PropertyIdentifier")
        int iLen = makeDevice4194303PropertyIdentifier()
        if(iLen > 0)
        {
           log.message("writeReg makeDevice4194303PropertyIdentifier($iLen)")
           writeReg(0, 0, iLen, buf)
        }
    }
    return isPortOpen = true
  }

  int bacnet_close(int ctx)
  {
    socket.close()
    isPortOpen = false
    return 1;
  }

  void createRPMAndWPM()
  {
     log.message("-------------------------------------------------------------------------------")
     log.message("-------------------------bacDevice update createRPMAndWPM-------------------------") 
     log.message("-------------------------------------------------------------------------------")
     bacnetMultipleReadCount = 0
     bacnetMultipleWriteCount = 0
     
     for (Component d = Sys.app.lookup(children); d != null; d = Sys.app.lookup(d.nextSibling)) {
        if (d.type.is(bacReadPropertyMultiple.type))  {
           int iObjectType = ((bacReadPropertyMultiple)d).objectNodeType
           int iInstanceNumber = ((bacReadPropertyMultiple)d).instanceNumber
           bacnetMultipleReadArray[bacnetMultipleReadCount] = iObjectType * 0x400000 + iInstanceNumber
           bacnetMultipleReadCount++
        } else if (d.type.is(bacWriteProperty.type))  {
           int iObjectType = ((bacWriteProperty)d).objectNodeType
           int iInstanceNumber = ((bacWriteProperty)d).instanceNumber
           
           bacnetMultipleWriteArray[bacnetMultipleWriteCount] = iObjectType * 0x400000 + iInstanceNumber
           bacnetMultipleWriteCount++
        }
     }
     
     log.message("bacnetMultipleReadCount = $bacnetMultipleReadCount")
     
     // RPM
     if(bacnetMultipleReadCount > 0)
     {
         operateMultipleProperty(BACNET_PROPERTY_READ, 
            bacnetMultipleReadArray, bacnetMultipleReadCount)
     }
     
     log.message("bacnetMultipleWriteCount = $bacnetMultipleWriteCount")
     // WPM
     if(bacnetMultipleWriteCount > 0)
     {
         operateMultipleProperty(BACNET_PROPERTY_WRITE,  
            bacnetMultipleWriteArray, bacnetMultipleWriteCount)
     }
  }

  void sortArray(int[] iData, int iLen)
  {
     int iSwap = 0 ;
     for (int i = 0; i < iLen; i++)
     {
        for (int j = i + 1; j < iLen; j++)
        {
            // Compare the iInstanceNumber rather than iObjectType
            int iCmpOne = iData[i] % 0x400000
            int iCmpTwo = iData[j] % 0x400000
            if(iCmpOne > iCmpTwo)
            {
                iSwap = iData[i];
                iData[i] = iData[j];
                iData[j] = iSwap;
            }
        }
     }
  }

  int searchIDBlock(int[] iData, int[] iOffset, int iLen)
  {
    int iBlockEnd = 0
    int iBlockLen = 0
    int iStartSearchPos = iOffset[0];
    for (int i = iStartSearchPos; i < iLen; i++)
    {
        // Compare the iInstanceNumber rather than iObjectType
        int iCmpOne = iData[i] % 0x400000
        int iCmpTwo = iData[i+1] % 0x400000
        if(iCmpOne + 1 == iCmpTwo)
        {
            iBlockEnd = i;
            iBlockLen++;
        }
        else if (iBlockLen > 0)
        {
            iBlockEnd = iBlockEnd + 1;
            iOffset[0] = iBlockEnd;
            iBlockLen = iBlockLen + 1;
            return iBlockLen;
        }         
    }
    return -1;
  }
  
  int operateMultipleProperty(int iOperateType, 
                                int[] iInstanceNumberList, int iLen)
  {
     int iStartPos = 0
     int iBlockLen = 0
     iListOffset[0] = 0;
     sortArray(iInstanceNumberList, iLen)
     
    for (int i = 0; i < iLen; i++)
    {
        log.message("iInstanceNumberList[$i] = ${iInstanceNumberList[i]}")
    }
     log.message("-------------------------bacDevice update operateMultipleProperty-------------------------") 
     while (iBlockLen != -1)
     {
        iBlockLen = searchIDBlock(
            iInstanceNumberList, iListOffset, iLen);
        if(iBlockLen != -1)
        {
            iStartPos = iListOffset[0] - iBlockLen + 1;
            log.message("Get Block at $iStartPos with $iBlockLen when iOperateType=$iOperateType ") 
            if(iBlockLen >= BACNET_PROPERTY_MULTIPLE_LIMIT)
            {
               operateOneBlock(iOperateType, iInstanceNumberList, iStartPos, iBlockLen);
            }
        }
     }
     return 1
  }
  
  int operateOneBlock(int iOperateType, int[] iData, int iStartPos, int iLen)
  {
     log.message("111 operateOneBlock Enter") 
     for (Component d = Sys.app.lookup(children); d != null; d = Sys.app.lookup(d.nextSibling)) {
         if (d.type.is(bacReadPropertyMultiple.type)
            && iOperateType == BACNET_PROPERTY_READ)  {
            // Assume We donot use ReadMultiple
            ((bacReadPropertyMultiple)d).bacnetReadMultipleCount = BACNET_READMULTIPLE_NOTUSED
           log.message("44444 operateOneBlock when instanceNumber=${((bacReadPropertyMultiple)d).instanceNumber}") 
           for (int i = iStartPos ; i < iStartPos + iLen; i++)
           {
              int iCmpOne = iData[i] % 0x400000
              if(iCmpOne == ((bacReadPropertyMultiple)d).instanceNumber)
              {
                 if(i != iStartPos)
                 {
                    // We use ReadMultiple and do nothing
                    log.message("666 bacReadPropertyMultiple Disable $i when iOperateType=$iOperateType") 
                   ((bacReadPropertyMultiple)d).bacnetReadMultipleCount = BACNET_READMULTIPLE_DONOTHING
                 }
                 else
                 {
                    // We use ReadMultiple and use instance number list
                     log.message("7777 bacReadPropertyMultiple Enable $i when iOperateType=$iOperateType") 
                   ((bacReadPropertyMultiple)d).bacnetReadMultipleCount = iLen
                    int j = 0
                    for (int k = iStartPos; k < iStartPos + iLen; k++)
                    {
                        
                        log.message("We will send ${iData[k]} in the bacReadPropertyMultiple which instanceNumber=${((bacReadPropertyMultiple)d).instanceNumber}") 
                        ((bacReadPropertyMultiple)d).bacnetReadMultipleList[j] = iData[k]
                        j++
                    }
                 }
              }
           }
        }
        else if (d.type.is(bacWriteProperty.type)
            && iOperateType == BACNET_PROPERTY_WRITE)  {
            // Assume We donot use WriteMultiple
            ((bacWriteProperty)d).bacnetWriteMultipleCount = BACNET_WRITEMULTIPLE_NOTUSED
           for (int i = iStartPos; i < iStartPos + iLen; i++)
           {
              int iCmpOne = iData[i] % 0x400000
              if(iCmpOne == ((BacNetFieldBusIO)d).instanceNumber)
              {
                 if(i != iStartPos)
                 {
                    // We use WriteMultiple and do nothing
                    log.message("666 bacWriteProperty Disable $i when iOperateType=$iOperateType") 
                    ((bacWriteProperty)d).bacnetWriteMultipleCount = BACNET_WRITEMULTIPLE_DONOTHING
                 }
                 else
                 {
                    // We use WriteMultiple and use instance number list
                     log.message("7777 bacWriteProperty Enable $i when iOperateType=$iOperateType") 
                    ((bacWriteProperty)d).bacnetWriteMultipleCount = iLen
                    int j = 0
                    for (int k = iStartPos ; k < iStartPos + iLen; k++)
                    {
                        log.message("We will send ${iData[k]} in the bacWriteProperty which instanceNumber=${((bacWriteProperty)d).instanceNumber}") 
                        ((bacWriteProperty)d).bacnetWriteMultipleList[j] = iData[k]
                        j++
                    }
                 }
              }
           }
        }
     }
     return -1;
  }
  
  // define Log log
  ////////////////////////////////////////////////////////////////
  // Fields
  ////////////////////////////////////////////////////////////////
  define int BACNET_PROPERTY_MULTIPLE_LIMIT = 3

  define int BACNET_PROPERTY_READ  = 1
  define int BACNET_PROPERTY_WRITE = 2
  
  define int BACNET_PROPERTY_READ_EXECUTE_TIMES   = 3
  define int BACNET_PROPERTY_WRITE_EXECUTE_TIMES  = 9
  
  define int BACNET_READMULTIPLE_NOTUSED    = -1
  define int BACNET_READMULTIPLE_DONOTHING  = 0
  
  define int BACNET_WRITEMULTIPLE_NOTUSED    = -1
  define int BACNET_WRITEMULTIPLE_DONOTHING  = 0
  
  FieldBusNet bus = null
  
  inline UdpSocket socket           // socket used for send/receive

  inline SocketAddr addrSendLocal             // remote endpoint address
  static inline UdpDatagram dataSendGram
  inline SocketAddr addrRecvLocal             // remote endpoint address
  static inline UdpDatagram dataRecvGram
  
  inline SocketAddr addrSendVTS  
  static inline UdpDatagram dataVTSForwardSendGram
  
  inline SocketAddr sockReadAddr

  private inline IpAddr    addrClient
  private inline Buf(5)    addrClientBuf
  
  bool isPortOpen                   // have we successfully opened the port

  private inline Str(128)   strInfo
  
  ** static inline byte[256] bacnetHead
  static inline byte[512] bacnetPacket
  inline Buf(512) packetSend
  inline Buf(512) packetRecv

  private inline int[2]    bufInteger
  private inline float[2]  bufFloat
  private inline double[2] bufDouble
  static inline byte[8]    bufData
  
  private inline float[512] bufToBIP
  
  private inline float[1024] buf
  static inline byte[1024] bacnetRecvPacket
  private       int dataLength
  
  inline Buf(64) lastInstanceNumber = ""

  // RPM
  int                     bacnetMultipleReadCount = 0
  inline static int[128]  bacnetMultipleReadArray
  
  // WPM
  int                     bacnetMultipleWriteCount = 0
  inline static int[128]  bacnetMultipleWriteArray
  // 
  inline static int[1] iListOffset;
  // 
  private       int execute_mode = BACNET_PROPERTY_WRITE
  private       int execute_counter = 0

  
  private int typeBVLCI = BVLCISTATUSUNICAST
  private int versionNPCI = 1
  private int hopCountNPCI = 255
  private int priorityNPCI = 0

  
   inline UdpSocket socketDetect           // socket used for send/receive
//   private inline int[2]    bufInteger
//   static inline byte[8]    bufData

   inline int[10]    ipArrayList
   inline int[10]    controlDstSpecList
   inline int[10]    NPDUList
   inline int[10]    objectIdentifierList
   inline int[10]    maxADPUList

   inline int[10]    ipRouterArrayList
   inline int[10]    networkNumberList

   int               bacnetCurrentDeviceRet = 0
}
