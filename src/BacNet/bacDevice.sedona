@niagaraIcon="module://icons/x16/device.png"
class bacDevice
  extends FieldBusDevice
{
  @config
  property int deviceInstance = 0

  // Lujiaming add these at 23/05/22
  define Str BVLCISTATUSRANGE = "NoBVLCI, DistributeBroadcastToNetWork, Unicast, Broadcast, ForwardNPDU_WT, END"
  define int BVLCISTATUSNOBVLCI = 0
  define int BVLCISTATUSDISTRIBUTEBROADCAST = 1
  define int BVLCISTATUSUNICAST = 2
  define int BVLCISTATUSBROADCAST = 3
  define int BVLCISTATUSFORARDNPDU = 4
  define int BVLCISTATUSEND = 5

  define Str NPCIRANGE = "Disable, Enable, END"
  define int DNETDISABLE = 0
  define int DNETENABLE = 1
  
  define int SNETDISABLE = 0
  define int SNETENABLE = 1
  
  define int DATAREPLYDISABLE = 0
  define int DATAREPLYENABLE = 1
  
  define int NPCIEND = 2

  
  define Str COMMUNICATIONMETHOD = "None, InstanceNumber, SubNetAndMAC, END"
  define int COMMUNICATIONNONE       = 0
  define int COMMUNICATIONBYINSTANCE = 1
  define int COMMUNICATIONBYSUBNET   = 2
  define int COMMUNICATIONEND = 3
  // Lujiaming add these end at 23/05/22
  
  @config
  @defaultOnClone
  @unit = Units.millisecond
  @min = 100
  property int refreshTime = 500

  @readonly
  @unit = Units.millisecond
  property int elapsedTime = -1

                          
  @range=COMMUNICATIONMETHOD
  @readonly property int communicationMethod = COMMUNICATIONNONE   

  // InstanceNumber
  @config
  property int InstanceNumber = 0
    
  // Lujiaming add these at 23/05/22
  @config
  @range = BVLCISTATUSRANGE
  @fieldWidth = 200
  property int typeBVLCI = BVLCISTATUSUNICAST

  // NPCI
  @config
  property int versionNPCI = 1

  // DNET/DLEN/DADR Present
  @readonly
  @range = NPCIRANGE
  @fieldWidth = 200
  property int dnetPresentNPCI = DNETENABLE
  
//  @config
//  property int dnetNPCI = 2401
  @config
  property int hopCountNPCI = 255
  
  // SNET/SLEN/SADR Present
  @readonly
  @range = NPCIRANGE
  @fieldWidth = 200
  property int snetPresentNPCI = SNETDISABLE
  
//  // Data Expecting Reply
//  @config
//  @range = NPCIRANGE
//  @fieldWidth = 200
//  property int dataExpectingReplyNPCI = DATAREPLYDISABLE
  
  @config
  property int priorityNPCI = 0
  // Lujiaming add these end at 23/05/22
  
  ////////////////////////////////////////////////////////////////
  // Life cycle
  ////////////////////////////////////////////////////////////////
  override void loaded()
  {
    update()
  }
  override void changed(Slot slot)
  {
    super.changed(slot)
    if (slot == bacDevice.deviceName || slot == bacDevice.deviceInstance || slot == bacDevice.refreshTime) {
      update()
    }
  }
  override void stop()
  {
    status := STATUSEND
    Component n = Sys.app.lookup(parent)
    if (n.type.is(FieldBusNet.type)) {
      ((FieldBusNet)n).update()
      ((FieldBusNet)n).notifyFlush()
    }
  }

  ////////////////////////////////////////////////////////////////
  // App support
  ////////////////////////////////////////////////////////////////
  void update()
  {
    Component n = Sys.app.lookup(parent)
    if (n != null && n.type.is(FieldBusNet.type)) {
      bus = (FieldBusNet)Sys.app.lookup(parent)
      ((FieldBusNet)n).update()
      ((FieldBusNet)n).notifyFlush()
      for (Component d = Sys.app.lookup(n.children); d != null; d = Sys.app.lookup(d.nextSibling)) {
        if (d == this) {
          continue
        }
        if (d.type.is(bacDevice.type) && ((bacDevice)d).deviceInstance == deviceInstance) {
          status := STATUSEADDR
          return
        }
      }
      if (deviceName.toStr().length() > 0) {
        Component s = Sys.app.lookup(n.parent)
        if (s != null && s.type.is(Folder.type) && s.name.equals("service")) {
          for (Component n1 = Sys.app.lookup(s.children); n1 != null; n1 = Sys.app.lookup(n1.nextSibling)) {
            if (n1.type.is(FieldBusNet.type)) {
              for (Component d = Sys.app.lookup(n1.children); d != null; d = Sys.app.lookup(d.nextSibling)) {
                if (d == this) {
                  continue
                }
                if (d.type.is(bacDevice.type) && ((bacDevice)d).deviceName.toStr().equals(deviceName.toStr())) {
                  status := STATUSENAME
                  return
                }
              }
            }
          }
        }
      } else {
        status := STATUSENAME
        return
      }
      status := STATUSNOREG
    } else {
      status := STATUSNONET
    }
  }

  override void execute()
  {
    ** log.message("bacDevice::execute 11111 status=$status") 
    if (bus != null) {
        if (bus.needFlush == false) {
            dataLength = bus.readReg(0, 0, 1024, buf)
            if(dataLength > 0)
            {
                log.message("We readReg and return $dataLength from ${bus.dataRecvGramAddr}")
                for(int i =0 ; i < dataLength; i++)
                {
                    //    log.message(
                    //        "execute readReg (0x").printHex(
                    //            (byte)buf[i]).print(") .").nl()
                    bacnetRecvPacket[i] = (byte)buf[i]
                }
                // bus.objectIdentifier = bus.sourceNetworkAddress = -1
                int iRet = bus.checkReadData(bacnetRecvPacket, dataLength)
                if(iRet == 0)
                {
                   log.message("We readReg and return (${bus.objectIdentifier}, ${bus.sourceNetworkAddress})")
                   log.message("          from ${bus.dataRecvGramAddr}")
                   bus.objectIdentifier = 240012
                   bus.dataRecvGramAddr = "192.168.168.241"

                   log.message("We use ${bus.objectIdentifier} temply")
                   bus.setClientAddress(bus.dataRecvGramAddr)
                }
            }
       //     else 
       //     {
       //         log.message("communicationMethod =$communicationMethod We need set it ")
       //     }
            
            ** log.message("Setting communicationMethod with ($lastInstanceNumber, $InstanceNumber)")
            if(lastInstanceNumber != InstanceNumber)
            {
               communicationMethod := bus.setClientAddressByInstanceNumber(InstanceNumber)
               lastInstanceNumber = InstanceNumber
            }
        }
        else 
        {
            log.message("We needFlush ")
        }
    }
  }
  
  int fillHead()
  {
    // BACnet Virtual Link Control
    // Type: BACnet/IP (Annex J) (0x81)
    bacnetPacket[0] = 0x81
    if(typeBVLCI == BVLCISTATUSDISTRIBUTEBROADCAST)
    {   
      bacnetPacket[1] = 0x9
    }
    else if(typeBVLCI == BVLCISTATUSUNICAST)
    {   
      // Function: Original-Unicast-NPDU (0x0a)
      bacnetPacket[1] = 0xA
    }
    else if(typeBVLCI == BVLCISTATUSBROADCAST)
    {   
      bacnetPacket[1] = 0xB
    }
    else 
    {   
      return -1
    }
    // Skip BVLC-Length: 4 of 18 bytes BACnet packet length
    bacnetPacket[2] = 0x00
    bacnetPacket[3] = 0x00
    // Building Automation and Control Network NPDU
    // NPCI Version: 0x01 (ASHRAE 135-1995)
    bacnetPacket[4] = versionNPCI
    // Control: 0x04, Expecting Reply
    if(communicationMethod == COMMUNICATIONBYSUBNET)
    {
        bacnetPacket[5] = 0x20
        // Building Automation and Control Network APDU
        bacnetPacket[5] += 0x04
        bacnetPacket[5] += priorityNPCI
        // dnetNPCI
        bacnetPacket[6] = bus.sourceNetworkAddress/256
        bacnetPacket[7] = bus.sourceNetworkAddress%256
        log.message("send sourceNetworkAddress =${bus.sourceNetworkAddress}")
    //  // Destination MAC Layer Address Length: 1
    //  bacnetPacket[8] = 0x01
    //  // DADR: 5
    //  log.message("send DADR =$sadr")
    //  bacnetPacket[9] = sadr
        // Destination MAC Layer Address Length: 0
        if(bus.sadr == 0)
        {
           bacnetPacket[8] = 0x00
        }
        else
        {
           bacnetPacket[8] = 0x01
           bacnetPacket[9] = bus.sadr
        }
        // hopCountNPCI
        bacnetPacket[10] = hopCountNPCI
        return 11
    }
    else if(communicationMethod == COMMUNICATIONBYINSTANCE)
    {   
        bacnetPacket[5] = 0x00
        bacnetPacket[5] += 0x04
        return 6
    }
    else 
    {   
      log.message("Error dataExpectingReplyNPCI with (${bus.sourceNetworkAddress}, ${bus.sadr})") 
      return -1
    }
  }

  override int writeReg(int deviceAddr, int addr, int iLen, float[] buf)
  { 
    int headLength = 0
    log.message("headLength=$headLength") 
    headLength = fillHead()
    if(headLength == -1)
        return headLength
    log.message("headLength=$headLength") 
    bacnetPacket[2] = (headLength + iLen)/256
    bacnetPacket[3] = (headLength + iLen)%256

    for(int i =0; i < headLength; i++)
    {
       bufToBIP[i] = (float)bacnetPacket[i]
    }
    
    for(int j =0; j < iLen; j++)
    {
       bufToBIP[j + headLength] = buf[j]
    }
    int iRet = bus.writeReg(deviceAddr, addr, iLen + headLength, bufToBIP)
    return iLen
  }

  // define Log log
  ////////////////////////////////////////////////////////////////
  // Fields
  ////////////////////////////////////////////////////////////////
  FieldBusNet bus = null
  
  ** static inline byte[256] bacnetHead
  static inline byte[512] bacnetPacket
  private inline float[512] bufToBIP
  
  private inline float[1024] buf
  static inline byte[1024] bacnetRecvPacket
  int dataLength
  
  int lastInstanceNumber = 0
}
